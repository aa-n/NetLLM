### CJS (Cluster Job Scheduling) 技术中文总结

#### **CJS 简介**
CJS（Cluster Job Scheduling）用于优化分布式计算环境中计算资源的分配，其中需要同时处理多个作业。CJS 的核心任务是根据策略对作业的阶段进行调度并分配资源（执行器），目的是 **最小化平均作业完成时间**，从而提高集群计算资源的系统级利用率。

每个作业用 **有向无环图（DAG）** 表示，描述了各执行阶段的依赖关系以及每个阶段的资源需求。调度策略的主要任务是：
- 选择作业的下一个阶段执行。
- 为该阶段分配计算资源。

#### **代码结构**
1. **核心目录**：
   - `artifacts`: 存储实验结果与经验池文件（LLM 适配数据）。
   - `stdout` 和 `checkpoints`: 基线模型训练的输出信息（可选）。
   - `config`: 配置文件目录，用于基线模型运行和训练。
   - `data`: 存储数据集，用于生成仿真环境。
   - `models`: 预训练模型的权重。
   - `spark_sched_sim`: 仿真环境的实现，基于开源项目 [spark-sched-sim](https://github.com/ArchieGertsman/spark-sched-sim)。
   - `trainers`: 相关训练代码。
   
2. **NetLLM 相关代码**：
   - `plm_special`:
     - `data`: 数据集与经验池代码。
     - `models`: 包括自定义 LLM（如 GPT2、Llama 和 T5）及相关模块（低秩矩阵、RL 策略等）。
     - `utils`: 工具代码（LLM 加载和数据处理）。
     - `trainer.py`: 训练过程包装类。
     - `evaluate.py` 和 `test.py`: 验证与测试代码。
   - `cfg_loader.py`: 基线模型配置文件加载。
   - `train_baseline.py`: 基线模型训练脚本。
   - `generate_exp_pool.py`: 经验池生成脚本。
   - `run_baseline.py`: 运行基线模型的主脚本。
   - `run_plm.py`: 运行 NetLLM 的主脚本。

#### **环境配置**
1. 创建 Python 环境：
   ```bash
   conda create -n cjs_netllm python=3.11.9 -y
   conda activate cjs_netllm
   ```
2. 安装依赖（包括 PyTorch、PyG、Gymnasium 等）。

#### **使用方法**
1. **运行 NetLLM**：
   - 需要先下载预训练的 LLM 权重（如 Llama2-7b），并放置在 `../downloaded_plms/llama2/base` 目录下。
   - **微调 LLM**：
     使用 `run_plm.py` 脚本进行微调：
     ```bash
     python run_plm.py --train --test --plm-type llama --plm-size base --device cuda:0 ...
     ```
     如果需要自定义经验池，先使用 `generate_exp_pool.py` 生成新的经验池，再在微调时指定路径。
   - **测试 LLM**：
     测试微调后的 LLM：
     ```bash
     python run_plm.py --test --plm-type llama --device cuda:0 --model-dir your_finetuned_llm_dir
     ```

2. **运行基线模型**：
   支持多种调度策略（如 FIFO、Fair 和 Decima），通过以下命令运行：
   ```bash
   python run_baseline.py --sched fifo --num-executors 50 --seed 666
   ```

#### **总结**
CJS 通过将 LLM（如 Llama2）适配到集群作业调度中，实现了更智能的资源分配与优化，支持通过经验池训练和微调，提高作业调度效率。


在上下文中，`tpch/2g/adj_mat_1.npy` 这样的数据文件通常用于描述集群作业调度中任务的 **有向无环图（DAG）** 的结构信息，具体含义可以如下解释：

### **文件路径的含义**
1. **`tpch`**：
   表示数据集来源。`TPCH` 通常是一个数据基准测试集，主要用于模拟事务处理和决策支持系统的查询作业。
   
2. **`2g`**：
   指代数据集规模，通常表示数据集大小。例如，这里可能是 2GB 的 TPCH 数据。

3. **`adj_mat_1.npy`**：
   - **`adj_mat`** 表示 **邻接矩阵（Adjacency Matrix）**。
   - **`1`** 表示文件的编号，可能对应某个特定作业的任务依赖图。
   - **`.npy`** 是 NumPy 数据格式，存储数组或矩阵。

### **邻接矩阵（Adjacency Matrix）的含义**
邻接矩阵是一种常用的图表示方式。在作业调度中，它用于描述任务依赖关系：
- 行和列表示任务（节点）。
- 元素值表示任务之间的依赖关系。

#### **矩阵的结构和内容**
- 如果矩阵为 \( A[i][j] \)：
  - \( A[i][j] = 1 \)：表示任务 \( i \) 是任务 \( j \) 的前置任务，任务 \( j \) 依赖任务 \( i \)。
  - \( A[i][j] = 0 \)：表示任务 \( i \) 与任务 \( j \) 无依赖关系。

#### **在 CJS 中的作用**
- **表示作业结构**：邻接矩阵描述了任务间的依赖关系，用于构建调度时的任务优先级。
- **输入特征编码**：在基于 Transformer 的调度策略中，邻接矩阵可能会作为特征输入，用于构建 DAG 的编码表示。
- **仿真环境生成**：用于初始化任务调度仿真环境，确定任务的执行顺序和依赖约束。

#### **例子**
假设 `adj_mat_1.npy` 文件的矩阵为：
```python
[[0, 1, 0],
 [0, 0, 1],
 [0, 0, 0]]
```
则任务依赖关系为：
- 任务 0 → 任务 1。
- 任务 1 → 任务 2。
- 任务 0 和任务 2 无直接依赖关系。

### **总结**
`tpch/2g/adj_mat_1.npy` 文件表示 2GB TPCH 数据集中某个作业的任务依赖结构，以邻接矩阵的形式存储，描述任务之间的依赖关系，作为调度策略的输入或仿真环境的基础数据。